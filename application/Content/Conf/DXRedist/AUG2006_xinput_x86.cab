pen
        else:
            popen = _popen
    if bufsize is None:
        return popen(cmd,mode)
    else:
        return popen(cmd,mode,bufsize)

def _norm_version(version, build=''):

    """ Normalize the version and build strings and return a single
        version string using the format major.minor.build (or patchlevel).
    """
    l = string.split(version,'.')
    if build:
        l.append(build)
    try:
        ints = map(int,l)
    except ValueError:
        strings = l
    else:
        strings = map(str,ints)
    version = string.join(strings[:3],'.')
    return version

_ver_output = re.compile(r'(?:([\w ]+) ([\w.]+) '
                         '.*'
                         '\[.* ([\d.]+)\])')

# Examples of VER command output:
#
#   Windows 2000:  Microsoft Windows 2000 [Version 5.00.2195]
#   Windows XP:    Microsoft Windows XP [Version 5.1.2600]
#   Windows Vista: Microsoft Windows [Version 6.0.6002]
#
# Note that the "Version" string gets localized on different
# Windows versions.

def _syscmd_ver(system='', release='', version='',

               supported_platforms=('win32','win16','dos','os2')):

    """ Tries to figure out the OS version used and returns
        a tuple (system,release,version).

        It uses the "ver" shell command for this which is known
        to exists on Windows, DOS and OS/2. XXX Others too ?

        In case this fails, the given parameters are used as
        defaults.

    """
    if sys.platform not in supported_platforms:
        return system,release,version

    # Try some common cmd strings
    for cmd in ('ver','command /c ver','cmd /c ver'):
        try:
            pipe = popen(cmd)
            info = pipe.read()
            if pipe.close():
                raise os.error,'command failed'
            # XXX How can I supress shell errors from being written
            #     to stderr ?
        except os.error,why:
            #print 'Command %s failed: %s' % (cmd,why)
            continue
        except IOError,why:
            #print 'Command %s failed: %s' % (cmd,why)
            continue
        else:
            break
    else:
        return system,release,version

    # Parse the output
    info = string.strip(info)
    m = _ver_output.match(info)
    if m is not None:
        system,release,version = m.groups()
        # Strip trailing dots from version and release
        if release[-1] == '.':
            release = release[:-1]
        if version[-1] == '.':
            version = version[:-1]
        # Normalize the version and build strings (eliminating additional
        # zeros)
        version = _norm_version(version)
    return system,release,version

def _win32_getvalue(key,name,default=''):

    """ Read a value for name from the registry key.

        In case this fails, default is returned.

    """
    try:
        # Use win32api if available
        from win32api import RegQueryValueEx
    except ImportError:
        # On Python 2.0 and later, emulate using _winreg
        import _winreg
        RegQueryValueEx = _winreg.QueryValueEx
    try:
        return RegQueryValueEx(key,name)
    except:
        return default

def win32_ver(release='',version='',csd='',ptype=''):

    """ Get additional version information from the Windows Registry
        and return a tuple (version,csd,ptype) referring to version
        number, CSD level and OS type (multi/single
        processor).

        As a hint: ptype returns 'Uniprocessor Free' on single
        processor NT machines and 'Multiprocessor Free' on multi
        processor machines. The 'Free' refers to the OS version being
        free of debugging code. It could also state 'Checked' which
        means the OS version uses debugging code, i.e. code that
        checks arguments, ranges, etc. (Thomas Heller).

        Note: this function works best with Mark Hammond's win32
        package installed, but also on Python 2.3 and later. It
        obviously only runs on Win32 compatible platforms.

    """
    # XXX Is there any way to find out the processor type on WinXX ?
    # XXX Is win32 available on Windows CE ?
    #
    # Adapted from code posted by Karl Putland to comp.lang.python.
    #
    # The mappings between reg. values and release names can be found
    # here: http://msdn.microsoft.com/library/en-us/sysinfo/base/osversioninfo_str.asp

    # Import the needed APIs
    try:
        import win32api
        from win32api import RegQueryValueEx, RegOpenKeyEx, \
             RegCloseKey, GetVersionEx
        from win32con import HKEY_LOCAL_MACHINE, VER_PLATFORM_WIN32_NT, \
             VER_PLATFORM_WIN32_WINDOWS, VER_NT_WORKSTATION
    except ImportError:
        # Emulate the win32api module using Python APIs
        try:
            sys.getwindowsversion
        except AttributeError:
            # No emulation possible, so return the defaults...
            return release,version,csd,ptype
        else:
            # Emulation using _winreg (added in Python 2.0) and
            # sys.getwindowsversion() (added in Python 2.3)
            import _winreg
            GetVersionEx = sys.getwindowsversion
            RegQueryValueEx = _winreg.QueryValueEx
            RegOpenKeyEx = _winreg.OpenKeyEx
            RegCloseKey = _winreg.CloseKey
            HKEY_LOCAL_MACHINE = _winreg.HKEY_LOCAL_MACHINE
            VER_PLATFORM_WIN32_WINDOWS = 1
            VER_PLATFORM_WIN32_NT = 2
            VER_NT_WORKSTATION = 1
            VER_NT_SERVER = 3
            REG_SZ = 1

    # Find out the registry key and some general version infos
    winver = GetVersionEx()
    maj,min,buildno,plat,csd = winver
    version = '%i.%i.%i' % (maj,min,buildno & 0xFFFF)
    if hasattr(winver, "service_pack"):
        if winver.service_pack != "":
            csd = 'SP%s' % winver.service_pack_major
    else:
        if csd[:13] == 'Service Pack ':
            csd = 'SP' + csd[13:]

    if plat == VER_PLATFORM_WIN32_WINDOWS:
        regkey = 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion'
        # Try to guess the release name
        if maj == 4:
            if min == 0:
                release = '95'
            elif min == 10:
                release = '98'
            elif min == 90:
                release = 'Me'
            else:
                release = 'postMe'
        elif maj == 5:
            release = '2000'

    elif plat == VER_PLATFORM_WIN32_NT:
        regkey = 'SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion'
        if maj <= 4:
            release = 'NT'
        elif maj == 5:
            if min == 0:
                release = '2000'
            elif min == 1:
                release = 'XP'
            elif min == 2:
                release = '2003Server'
            else:
                release = 'post2003'
        elif maj == 6:
            if hasattr(winver, "product_type"):
                product_type = winver.product_type
            else:
                product_type = VER_NT_WORKSTATION
                # Without an OSVERSIONINFOEX capable sys.getwindowsversion(),
                # or help from the registry, we cannot properly identify
                # non-workstation versions.
                try:
                    key = RegOpenKeyEx(HKEY_LOCAL_MACHINE, regkey)
                    name, type = RegQueryValueEx(key, "ProductName")
                    # Discard any type that isn't REG_SZ
                    if type == REG_SZ and name.find("Server") != -1:
                        product_type = VER_NT_SERVER
                except WindowsError:
                    # Use default of VER_NT_WORKSTATION
                    pass

            if min == 0:
                if product_type == VER_NT_WORKSTATION:
                    release = 'Vista'
                else:
                    release = '2008Server'
            elif min == 1:
                if product_type == VER_NT_WORKSTATION:
                    release = '7'
                else:
                    release = '2008ServerR2'
            else:
                release = 'post2008Server'

    else:
        if not release:
            # E.g. Win3.1 with win32s
            release = '%i.%i' % (maj,min)
        return release,version,csd,ptype

    # Open the registry key
    try:
        keyCurVer = RegOpenKeyEx(HKEY_LOCAL_MACHINE, regkey)
        # Get a value to make sure the key exists...
        RegQueryValueEx(keyCurVer, 'SystemRoot')
    except:
        return release,version,csd,ptype

    # Parse values
    #subversion = _win32_getvalue(keyCurVer,
    #                            'SubVersionNumber',
    #                            ('',1))[0]
    #if subversion:
    #   release = release + subversion # 95a, 95b, etc.
    build = _win32_getvalue(keyCurVer,
                            'CurrentBuildNumber',
                            ('',1))[0]
    ptype = _win32_getvalue(keyCurVer,
                           'CurrentType',
                           (ptype,1))[0]

    # Normalize version
    version = _norm_version(version,build)

    # Close key
    RegCloseKey(keyCurVer)
    return release,version,csd,ptype

def _mac_ver_lookup(selectors,default=None):

    from gestalt import gestalt
    import MacOS
    l = []
    append = l.append
    for selector in selectors:
        try:
            append(gestalt(selector))
        except (RuntimeError, MacOS.Error):
            append(default)
    return l

def _bcd2str(bcd):

    return hex(bcd)[2:]

def _mac_ver_gestalt():
    """
        Thanks to Mark R. Levinson for mailing documentation links and
        code examples for this function. Documentation for the
        gestalt() API is available online at:

           http://www.rgaros.nl/gestalt/
    """
    # Check whether the version info module is available
    try:
        import gestalt
        import MacOS
    except ImportError:
        return None
    # Get the infos
    sysv,sysa = _mac_ver_lookup(('sysv','sysa'))
    # Decode the infos
    if sysv:
        major = (sysv & 0xFF00) >> 8
        minor = (sysv & 0x00F0) >> 4
        patch = (sysv & 0x000F)

        if (major, minor) >= (10, 4):
            # the 'sysv' gestald cannot return patchlevels
            # higher than 9. Apple introduced 3 new
            # gestalt codes in 10.4 to deal with this
            # issue (needed because patch levels can
            # run higher than 9, such as 10.4.11)
            major,minor,patch = _mac_ver_lookup(('sys1','sys2','sys3'))
            release = '%i.%i.%i' %(major, minor, patch)
        else:
            release = '%s.%i.%i' % (_bcd2str(major),minor,patch)

    if sysa:
        machine = {0x1: '68k',
                   0x2: 'PowerPC',
                   0xa: 'i386'}.get(sysa,'')

    return release,versioninfo,machine

def _mac_ver_xml():
    fn = '/System/Library/CoreServices/SystemVersion.plist'
    if not os.path.exists(fn):
        return None

    try:
        import plistlib
    except ImportError:
        return None

    pl = plistlib.readPlist(fn)
    release = pl['ProductVersion']
    versioninfo=('', '', '')
    machine = os.uname()[4]
    if machine in ('ppc', 'Power Macintosh'):
        # for compatibility with the gestalt based code
        machine = 'PowerPC'

    return release,versioninfo,machine


def mac_ver(release='',versioninfo=('','',''),machine=''):

    """ Get MacOS version information and return it as tuple (release,
        versioninfo, machine) with versioninfo being a tuple (version,
        dev_stage, non_release_version).

        Entries which cannot be determined are set to the paramter values
        which default to ''. All tuple entries are strings.
    """

    # First try reading the information from an XML file which should
    # always be present
    info = _mac_ver_xml()
    if info is not None:
        return info

    # If that doesn't work for some reason fall back to reading the
    # information using gestalt calls.
    info = _mac_ver_gestalt()
    if info is not None:
        return info

    # If that also doesn't work return the default values
    return release,versioninfo,machine

def _java_getprop(name,default):

    from java.lang import System
    try:
        value = System.getProperty(name)
        if value is None:
            return default
        return value
    except AttributeError:
        return default

def java_ver(release='',vendor='',vminfo=('','',''),osinfo=('','','')):

    """ Version interface for Jython.

        Returns a tuple (release,vendor,vminfo,osinfo) with vminfo being
        a tuple (vm_name,vm_release,vm_vendor) and osinfo being a
        tuple (os_name,os_version,os_arch).

        Values which cannot be determined are set to the defaults
        given as parameters (which all default to '').

    """
    # Import the needed APIs
    try:
        import java.lang
    except ImportError:
        return release,vendor,vminfo,osinfo

    vendor = _java_getprop('java.vendor', vendor)
    release = _java_getprop('java.version', release)
    vm_name, vm_release, vm_vendor = vminfo
    vm_name = _java_getprop('java.vm.name', vm_name)
    vm_vendor = _java_getprop('java.vm.vendor', vm_vendor)
    vm_release = _java_getprop('java.vm.version', vm_release)
    vminfo = vm_name, vm_release, vm_vendor
    os_name, os_version, os_arch = osinfo
    os_arch = _java_getprop('java.os.arch', os_arch)
    os_name = _java_getprop('java.os.name', os_name)
    os_version = _java_getprop('java.os.version', os_version)
    osinfo = os_name, os_version, os_arch

    return release, vendor, vminfo, osinfo

### System name aliasing

def system_alias(system,release,version):

    """ Returns (system,release,version) aliased to common
        marketing names used for some systems.

        It also does some reordering of the information in some cases
        where it would otherwise cause confusion.

    """
    if system == 'Rhapsody':
        # Apple's BSD derivative
        # XXX How can we determine the marketing release number ?
        return 'MacOS X Server',system+release,version

    elif system == 'SunOS':
        # Sun's OS
        if release < '5':
            # These releases use the old name SunOS
            return system,release,version
        # Modify release (marketing release = SunOS release - 3)
        l = string.split(release,'.')
        if l:
            try:
                major = int(l[0])
            except ValueError:
                pass
            else:
                major = major - 3
                l[0] = str(major)
                release = string.join(l,'.')
        if release < '6':
            system = 'Solaris'
        else:
            # XXX Whatever the new SunOS marketing name is...
            system = 'Solaris'

    elif system == 'IRIX64':
        # IRIX reports IRIX64 on platforms with 64-bit support; yet it
        # is really a version and not a different platform, since 32-bit
        # apps are also supported..
        system = 'IRIX'
        if version:
            version = version + ' (64bit)'
        else:
            version = '64bit'

    elif system in ('win32','win16'):
        # In case one of the other tricks
        system = 'Windows'

    return system,release,version

### Various internal helpers

def _platform(*args):

    """ Helper to format the platform string in a filename
        compatible format e.g. "system-version-machine".
    """
    # Format the platform string
    platform = string.join(
        map(string.strip,
            filter(len, args)),
        '-')

    # Cleanup some possible filename obstacles...
    replace = string.replace
    platform = replace(platform,' ','_')
    platform = replace(platform,'/','-')
    platform = replace(platform,'\\','-')
    platform = replace(platform,':','-')
    platform = replace(platform,';','-')
    platform = replace(platform,'"','-')
    platform = replace(platform,'(','-')
    platform = replace(platform,')','-')

    # No need to report 'unknown' information...
    platform = replace(platform,'unknown','')

    # Fold '--'s and remove trailing '-'
    while 1:
        cleaned = replace(platform,'--','-')
        if cleaned == platform:
            break
        platform = cleaned
    while platform[-1] == '-':
        platform = platform[:-1]

    return platform

def _node(default=''):

    """ Helper to determine the node name of this machine.
    """
    try:
        import socket
    except ImportError:
        # No sockets...
        return default
    try:
        return socket.gethostname()
    except socket.error:
        # Still not working...
        return default

# os.path.abspath is new in Python 1.5.2:
if not hasattr(os.path,'abspath'):

    def _abspath(path,

                 isabs=os.path.isabs,join=os.path.join,getcwd=os.getcwd,
                 normpath=os.path.normpath):

        if not isabs(path):
            path = join(getcwd(), path)
        return normpath(path)

else:

    _abspath = os.path.abspath

def _follow_symlinks(filepath):

    """ In case filepath is a symlink, follow it until a
        real file is reached.
    """
    filepath = _abspath(filepath)
    while os.path.islink(filepath):
        filepath = os.path.normpath(
            os.path.join(os.path.dirname(filepath),os.readlink(filepath)))
    return filepath

def _syscmd_uname(option,default=''):

    """ Interface to the system's uname command.
    """
    if sys.platform in ('dos','win32','win16','os2'):
        # XXX Others too ?
        return default
    try:
        f = os.popen('uname %s 2> %s' % (option, DEV_NULL))
    except (AttributeError,os.error):
        return default
    output = string.strip(f.read())
    rc = f.close()
    if not output or rc:
        return default
    else:
        return output

def _syscmd_file(target,default=''):

    """ Interface to the system's file command.

        The function uses the -b option of the file command to have it
        ommit the filename in its output and if possible the -L option
        to have the command follow symlinks. It returns default in
        case the command should fail.

    """
    if sys.platform in ('dos','win32','win16','os2'):
        # XXX Others too ?
        return default
    target = _follow_symlinks(target).replace('"', '\\"')
    try:
        f = os.popen('file "%s" 2> %s' % (target, DEV_NULL))
    except (AttributeError,os.error):
        return default
    output = string.strip(f.read())
    rc = f.close()
    if not output or rc:
        return default
    else:
        return output

### Information about the used architecture

# Default values for architecture; non-empty strings override the
# defaults given as parameters
_default_architecture = {
    'win32': ('','WindowsPE'),
    'win16': ('','Windows'),
    'dos': ('','MSDOS'),
}

_architecture_split = re.compile(r'[\s,]').split

def architecture(executable=sys.executable,bits='',linkage=''):

    """ Queries the given executable (defaults to the Python interpreter
        binary) for various architecture information.

        Returns a tuple (bits,linkage) which contains information about
        the bit architecture and the linkage format used for the
        executable. Both values are returned as strings.

        Values that cannot be determined are returned as given by the
        parameter presets. If bits is given as '', the sizeof(pointer)
        (or sizeof(long) on Python version < 1.5.2) is used as
        indicator for the supported pointer size.

        The function relies on the system's "file" command to do the
        actual work. This is available on most if not all Unix
        platforms. On some non-Unix platforms where the "file" command
        does not exist and the executable is set to the Python interpreter
        binary defaults from _default_architecture are used.

    """
    # Use the sizeof(pointer) as default number of bits if nothing
    # else is given as default.
    if not bits:
        import struct
        try:
            size = struct.calcsize('P')
        except struct.error:
            # Older installations can only query longs
            size = struct.calcsize('l')
        bits = str(size*8) + 'bit'

    # Get data from the 'file' system command
    if executable:
        output = _syscmd_file(executable, '')
    else:
        output = ''

    if not output and \
       executable == sys.executable:
        # "file" command did not return anything; we'll try to provide
        # some sensible defaults then...
        if sys.platform in _default_architecture:
            b, l = _default_architecture[sys.platform]
            if b:
                bits = b
            if l:
                linkage = l
        return bits, linkage

    # Split the output into a list of strings omitting the filename
    fileout = _architecture_split(output)[1:]

    if 'executable' not in fileout:
        # Format not supported
        return bits,linkage

    # Bits
    if '32-bit' in fileout:
        bits = '32bit'
    elif 'N32' in fileout:
        # On Irix only
        bits = 'n32bit'
    elif '64-bit' in fileout:
        bits = '64bit'

    # Linkage
    if 'ELF' in fileout:
        linkage = 'ELF'
    elif 'PE' in fileout:
        # E.g. Windows uses this format
        if 'Windows' in fileout:
            linkage = 'WindowsPE'
        else:
            linkage = 'PE'
    elif 'COFF' in fileout:
        linkage = 'COFF'
    elif 'MS-DOS' in fileout:
        linkage = 'MSDOS'
    else:
        # XXX the A.OUT format also falls under this class...
        pass

    return bits,linkage

### Portable uname() interface

_uname_cache = None

def uname():

    """ Fairly portable uname interface. Returns a tuple
        of strings (system,node,release,version,machine,processor)
        identifying the underlying platform.

        Note that unlike the os.uname function this also returns
        possible processor information as an additional tuple entry.

        Entries which cannot be determined are set to ''.

    """
    global _uname_cache
    no_os_uname = 0

    if _uname_cache is not None:
        return _uname_cache

    processor = ''

    # Get some infos from the builtin os.uname API...
    try:
        system,node,release,version,machine = os.uname()
    except AttributeError:
        no_os_uname = 1

    if no_os_uname or not filter(None, (system, node, release, version, machine)):
        # Hmm, no there is either no uname or uname has returned
        #'unknowns'... we'll have to poke around the system then.
        if no_os_uname:
            system = sys.platform
            release = ''
            version = ''
            node = _node()
            machine = ''

        use_syscmd_ver = 1

        # Try win32_ver() on win32 platforms
        if system == 'win32':
            release,version,csd,ptype = win32_ver()
            if release and version:
                use_syscmd_ver = 0
            # Try to use the PROCESSOR_* environment variables
            # available on Win XP and later; see
            # http://support.microsoft.com/kb/888731 and
            # http://www.geocities.com/rick_lively/MANUALS/ENV/MSWIN/PROCESSI.HTM
            if not machine:
                # WOW64 processes mask the native architecture
                if "PROCESSOR_ARCHITEW6432" in os.environ:
                    machine = os.environ.get("PROCESSOR_ARCHITEW6432", '')
                else:
                    machine = os.environ.get('PROCESSOR_ARCHITECTURE', '')
            if not processor:
                processor = os.environ.get('PROCESSOR_IDENTIFIER', machine)

        # Try the 'ver' system command available on some
        # platforms
        if use_syscmd_ver:
            system,release,version = _syscmd_ver(system)
            # Normalize system to what win32_ver() normally returns
            # (_syscmd_ver() tends to return the vendor name as well)
            if system == 'Microsoft Windows':
                system = 'Windows'
            elif system == 'Microsoft' and release == 'Windows':
                # Under Windows Vista and Windows Server 2008,
                # Microsoft changed the output of the ver command. The
                # release is no longer printed.  This causes the
                # system and release to be misidentified.
                system = 'Windows'
                if '6.0' == version[:3]:
                    release = 'Vista'
                else:
                    release = ''

        # In case we still don't know anything useful, we'll try to
        # help ourselves
        if system in ('win32','win16'):
            if not version:
                if system == 'win32':
                    version = '32bit'
                else:
                    version = '16bit'
            system = 'Windows'

        elif system[:4] == 'java':
            release,vendor,vminfo,osinfo = java_ver()
            system = 'Java'
            version = string.join(vminfo,', ')
            if not version:
                version = vendor

    # System specific extensions
    if system == 'OpenVMS':
        # OpenVMS seems to have release and version mixed up
        if not release or release == '0':
            release = version
            version = ''
        # Get processor information
        try:
            import vms_lib
        except ImportError:
            pass
        else:
            csid, cpu_number = vms_lib.getsyi('SYI$_CPU',0)
            if (cpu_number >= 128):
                processor = 'Alpha'
            else:
                processor = 'VAX'
    if not processor:
        # Get processor information from the uname system command
        processor = _syscmd_uname('-p','')

    #If any unknowns still exist, replace them with ''s, which are more portable
    if system == 'unknown':
        system = ''
    if node == 'unknown':
        node = ''
    if release == 'unknown':
        release = ''
    if version == 'unknown':
        version = ''
    if machine == 'unknown':
        machine = ''
    if processor == 'unknown':
        processor = ''

    #  normalize name
    if system == 'Microsoft' and release == 'Windows':
        system = 'Windows'
        release = 'Vista'

    _uname_cache = system,node,release,version,machine,processor
    return _uname_cache

### Direct interfaces to some of the uname() return values

def system():

    """ Returns the system/OS name, e.g. 'Linux', 'Windows' or 'Java'.

        An empty string is returned if the value cannot be determined.

    """
    return uname()[0]

def node():

    """ Returns the computer's network name (which may not be fully
        qualified)

        An empty string is returned if the value cannot be determined.

    """
    return uname()[1]

def release():

    """ Returns the system's release, e.g. '2.2.0' or 'NT'

        An empty string is returned if the value cannot be determined.

    """
    return uname()[2]

def version():

    """ Returns the system's release version, e.g. '#3 on degas'

        An empty string is returned if the value cannot be determined.

    """
    return uname()[3]

def machine():

    """ Returns the machine type, e.g. 'i386'

        An empty string is returned if the value cannot be determined.

    """
    return uname()[4]

def processor():

    """ Returns the (true) processor name, e.g. 'amdk6'

        An empty string is returned if the value cannot be
        determined. Note that many platforms do not provide this
        information or simply return the same value as for machine(),
        e.g.  NetBSD does this.

    """
    return uname()[5]

### Various APIs for extracting information from sys.version

_sys_version_parser = re.compile(
    r'([\w.+]+)\s*'
    '\(#?([^,]+),\s*([\w ]+),\s*([\w :]+)\)\s*'
    '\[([^\]]+)\]?')

_ironpython_sys_version_parser = re.compile(
    r'IronPython\s*'
    '([\d\.]+)'
    '(?: \(([\d\.]+)\))?'
    ' on (.NET [\d\.]+)')

_pypy_sys_version_parser = re.compile(
    r'([\w.+]+)\s*'
    '\(#?([^,]+),\s*([\w ]+),\s*([\w :]+)\)\s*'
    '\[PyPy [^\]]+\]?')

_sys_version_cache = {}

def _sys_version(sys_version=None):

    """ Returns a parsed version of Python's sys.version as tuple
        (name, version, branch, revision, buildno, builddate, compiler)
        referring to the Python implementation name, version, branch,
        revision, build number, build date/time as string and the compiler
        identification string.

        Note that unlike the Python sys.version, the returned value
        for the Python version will always include the patchlevel (it
        defaults to '.0').

        The function returns empty strings for tuple entries that
        cannot be determined.

        sys_version may be given to parse an alternative version
        string, e.g. if the version was read from a different Python
        interpreter.

    """
    # Get the Python version
    if sys_version is None:
        sys_version = sys.version

    # Try the cache first
    result = _sys_version_cache.get(sys_version, None)
    if result is not None:
        return result

    # Parse it
    if sys_version[:10] == 'IronPython':
        # IronPython
        name = 'IronPython'
        match = _ironpython_sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError(
                'failed to parse IronPython sys.version: %s' %
                repr(sys_version))
        version, alt_version, compiler = match.groups()
        buildno = ''
        builddate = ''

    elif sys.platform[:4] == 'java':
        # Jython
        name = 'Jython'
        match = _sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError(
                'failed to parse Jython sys.version: %s' %
                repr(sys_version))
        version, buildno, builddate, buildtime, _ = match.groups()
        compiler = sys.platform

    elif "PyPy" in sys_version:
        # PyPy
        name = "PyPy"
        match = _pypy_sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError("failed to parse PyPy sys.version: %s" %
                             repr(sys_version))
        version, buildno, builddate, buildtime = match.groups()
        compiler = ""

    else:
        # CPython
        match = _sys_version_parser.match(sys_version)
        if match is None:
            raise ValueError(
                'failed to parse CPython sys.version: %s' %
                repr(sys_version))
        version, buildno, builddate, buildtime, compiler = \
              match.groups()
        name = 'CPython'
        builddate = builddate + ' ' + buildtime

    if hasattr(sys, 'subversion'):
        # sys.subversion was added in Python 2.5
        _, branch, revision = sys.subversion
    else:
        branch = ''
        revision = ''

    # Add the patchlevel version if missing
    l = string.split(version, '.')
    if len(l) == 2:
        l.append('0')
        version = string.join(l, '.')

    # Build and cache the result
    result = (name, version, branch, revision, buildno, builddate, compiler)
    _sys_version_cache[sys_version] = result
    return result

def python_implementation():

    """ Returns a string identifying the Python implementation.

        Currently, the following implementations are identified:
        'CPython' (C implementation of Python),
        'IronPython' (.NET implementation of Python),
        'Jython' (Java implementation of Python).

    """
    return _sys_version()[0]

def python_version():

    """ Returns the Python version as string 'major.minor.patchlevel'

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    """
    return _sys_version()[1]

def python_version_tuple():

    """ Returns the Python version as tuple (major, minor, patchlevel)
        of strings.

        Note that unlike the Python sys.version, the returned value
        will always include the patchlevel (it defaults to 0).

    """
    return tuple(string.split(_sys_version()[1], '.'))

def python_branch():

    """ Returns a string identifying the Python implementation
        branch.

        For CPython this is the Subversion branch from which the
        Python binary was built.

        If not available, an empty string is returned.

    """

    return _sys_version()[2]

def python_revision():

    """ Returns a string identifying the Python implementation
        revision.

        For CPython this is the Subversion revision from which the
        Python binary was built.

        If not available, an empty string is returned.

    """
    return _sys_version()[3]

def python_build():

    """ Returns a tuple (buildno, builddate) stating the Python
        build number and date as strings.

    """
    return _sys_version()[4:6]

def python_compiler():

    """ Returns a string identifying the compiler used for compiling
        Python.

    """
    return _sys_version()[6]

### The Opus Magnum of platform strings :-)

_platform_cache = {}

def platform(aliased=0, terse=0):

    """ Returns a single string identifying the underlying platform
        with as much useful information as possible (but no more :).

        The output is intended to be human readable rather than
        machine parseable. It may look different on different
        platforms and this is intended.

        If "aliased" is true, the function will use aliases for
        various platforms that report system names which differ from
        their common names, e.g. SunOS will be reported as
        Solaris. The system_alias() function is used to implement
        this.

        Setting terse to true causes the function to return only the
        absolute minimum information needed to identify the platform.

    """
    result = _platform_cache.get((aliased, terse), None)
    if result is not None:
        return result

    # Get uname information and then apply platform specific cosmetics
    # to it...
    system,node,release,version,machine,processor = uname()
    if machine == processor:
        processor = ''
    if aliased:
        system,release,version = system_alias(system,release,version)

    if system == 'Windows':
        # MS platforms
        rel,vers,csd,ptype = win32_ver(version)
        if terse:
            platform = _platform(system,release)
        else:
            platform = _platform(system,release,version,csd)

    elif system in ('Linux',):
        # Linux based systems
        distname,distversion,distid = dist('')
        if distname and not terse:
            platform = _platform(system,release,machine,processor,
                                 'with',
                                 distname,distversion,distid)
        else:
            # If the distribution name is unknown check for libc vs. glibc
            libcname,libcversion = libc_ver(sys.executable)
            platform = _platform(system,release,machine,processor,
                                 'with',
                                 libcname+libcversion)
    elif system == 'Java':
        # Java platforms
        r,v,vminfo,(os_name,os_version,os_arch) = java_ver()
        if terse or not os_name:
            platform = _platform(system,release,version)
        else:
            platform = _platform(system,release,version,
                                 'on',
                                 os_name,os_version,os_arch)

    elif system == 'MacOS':
        # MacOS platforms
        if terse:
            platform = _platform(system,release)
        else:
            platform = _platform(system,release,machine)

    else:
        # Generic handler
        if terse:
            platform = _platform(system,release)
        else:
            bits,linkage = architecture(sys.executable)
            platform = _platform(system,release,machine,processor,bits,linkage)

    _platform_cache[(aliased, terse)] = platform
    return platform

### Command line interface

if __name__ == '__main__':
    # Default is to print the aliased verbose platform string
    terse = ('terse' in sys.argv or '--terse' in sys.argv)
    aliased = (not 'nonaliased' in sys.argv and not '--nonaliased' in sys.argv)
    print platform(aliased,terse)
    sys.exit(0)
                                                                                                                                                                                                                                                                                                                                                                                                                                                      Pbˆ'ÿ Pbˆ—ÿ ®_bˆKÛ  ebˆ×æ hbˆ	á wbˆw	 î|bˆÃã -ƒbˆ*œ æbˆºy k™bˆÙ 5›bˆm bˆ"£ 
¨bˆòu {©bˆaÍ d¯bˆîc ¾´bˆF¥ ¾´bˆÛ @Æbˆˆ Íbˆ¾ aÓbˆ5ï 4âbˆÖ ØäbˆƒÛ ©ñbˆ#ç úóbˆWÕ ½öbˆİõ ûbˆê âcˆUÄ HcˆÉû HcˆŒ˜ $cˆÏÄ vcˆQü vcˆ¼` q"cˆ q"cˆ§Ø ==cˆËÀ @cˆAù @cˆÁ óEcˆ¯Ã »Pcˆíú »Pcˆì ğZcˆ@]  ^cˆØ˜  ^cˆd‘ £bcˆÃá fcˆÔ Jfcˆ‡
 JfcˆRƒ Khcˆ½Ç Whcˆÿ Whcˆ¤ Étcˆ¿ Étcˆh 1”cˆ‹Å |™cˆçü |™cˆ¡ì /šcˆÛ IÁcˆá  EØcˆ€m =Ùcˆ°— 
ácˆ?à 6ëcˆ›é ¨òcˆó ’úcˆGõ 2ıcˆƒÉ –şcˆñÔ ÿcˆYã Jdˆıê _
dˆÎ hdˆG hdˆıì ]dˆ¢‰ ?dˆ^• ©dˆ m "dˆ-ç 'dˆ“ì º1dˆ;÷ Ä4dˆ” ˜5dˆ±ï YGdˆf  	SdˆáÃ ÄWdˆCà <sdˆ\– (€dˆ¦‡ ë‚dˆ
Š •dˆºŠ ®¬dˆÖt ¼dˆt ¥¾dˆ«ß ³Çdˆ³å ?Ëdˆ^k iÎdˆú Ãİdˆ3ß èdˆBa ¦ìdˆl ¦ìdˆº eˆô eˆé¾ eˆŞ_ A-eˆŠš A-eˆÑñ `6eˆÀ £@eˆø £@eˆL› ´Ueˆ»æ ÑUeˆ]× ‰Zeˆ%Ø @_eˆX” ¯ceˆ×Ğ OjeˆEÎ $keˆq $keˆ³º loeˆ  ƒoeˆu ùveˆo× ?|eˆ«Æ ß†eˆ(q ˆeˆó¹ ÛŠeˆ‰ó ÛŠeˆò£ &’eˆíÍ ç˜eˆ+ ç˜eˆuä ı™eˆa¸ eˆ‡ñ eˆğ 6¨eˆà s©eˆ³· Ã±eˆ+ê 2¸eˆÑ TÊeˆûî >ÏeˆkÅ ÚeˆÉü ÚeˆÀ Úİeˆù Úİeˆˆ Eæeˆ» üçeˆûÜ ŞîeˆL  ºïeˆSß ¦öeˆİç ñúeˆU ûeˆSß ÊûeˆV‘ tüeˆ•Â ß fˆ…ù Xfˆ›é Rfˆğ” ªfˆ%õ u%fˆı ~2fˆÉã }3fˆYò ô9fˆË PKfˆ%Ô `afˆ½Õ bfˆ{é İdfˆƒ ˜mfˆ‡ã AzfˆÅÃ b†fˆ=û b†fˆµü {ˆfˆeé hfˆÓğ 1©fˆÖg g¬fˆº lÃfˆ•ó lÃfˆ~n ­ÄfˆsÔ ÚäfˆuÒ }ìfˆ'	 }ìfˆ9Â õfˆú õfˆ-õ şfˆÂ íÿfˆ‡¹ 
gˆ9ü ÓgˆqÚ +gˆ5Ü Wgˆ± 2gˆ­ü ugˆ { À"gˆå v+gˆû Â7gˆ” ·@gˆr† GBgˆà ·Hgˆ§¹ êUgˆ÷ ûagˆ±ã ³cgˆß· dgˆ]ç fgˆ m€gˆÂ îƒgˆOú îƒgˆsº ^Šgˆ3ô ^Šgˆ=	 .gˆh }gˆ+ı ä’gˆqÿ šgˆGİ ^gˆûí Ğ°gˆeè 7»gˆkÏ Ğ¿gˆ!Ï kÆgˆY kÆgˆç áĞgˆ=ü ¬Ògˆ+Ä 5Ügˆ›û 5Ügˆè lŞgˆûÄ gègˆyü gègˆìu úgˆ1ë hˆ÷æ lhˆc÷ °hˆ0 hˆ)á @hˆYı whˆ²… Éhˆ•Í whˆß whˆg À*hˆıÆ +8hˆ{ş +8hˆ¿ş ì=hˆ¯Í Š@hˆó Š@hˆ(š ADhˆ›Ó şDhˆ
 şDhˆ ¨Ehˆ¤ RhˆGÉ 0ghˆv”  mhˆíë hmhˆÿ¿ uhˆ©ø uhˆ*n ÛvhˆÛÌ ¨‚hˆåâ —hˆ¾‘ ÿ¤hˆ× ­hˆô }°hˆğk <²hˆ 
¶hˆ{â ì¼hˆí ÀÀhˆ‰× kÉhˆ±ö -Ğhˆûå sĞhˆ?â Óhˆö™ ²ÚhˆĞ çİhˆÃº •îhˆ?ô •îhˆg» ¢iˆd— ®iˆ×Ò "iˆóã Â*iˆ1ú ½,iˆ£À ×/iˆß× …HiˆiÖ úPiˆ(l <Riˆ©ÿ z[iˆW ûciˆıë ydiˆÎb ’kiˆˆ¡ ’kiˆ)¿ Öriˆ•÷ ÖriˆÍî `xiˆçà 2|iˆb… Óiˆ?Ä ®•iˆ³û ®•iˆ¯Á ê•iˆqù ê•iˆ9Û `—iˆaº À—iˆô À—iˆ=å ÉšiˆLh ¢iˆ!Ã #§iˆü Z¨iˆ‘â f³iˆä| ­·iˆ·× ÀÈiˆ·Ó ÇÉiˆ/Æ ½Ùiˆâ eáiˆ× wíiˆ;¸ äğiˆ[ñ äğiˆ}Ñ ²õiˆ9 ²õiˆßÓ EjˆQ
 Ejˆ?Ş "	jˆút HjˆéÁ ÷jˆâv ‡jˆ%Ô ô5jˆŸÅ 	Cjˆo êCjˆò Ijˆ’— ]jˆGÆ ıajˆÉı ıajˆ‰º hmjˆî ÏmjˆéÄ Ùnjˆeü ÙnjˆiÀ /ojˆ+ù /ojˆ¯ã õ–jˆ´¥ ²jˆ£î ¢jˆŸ  ¾jˆÎ— ]Ëjˆà‘ )Íjˆ3ü Ïjˆñì äàjˆë [æjˆãë zôjˆiã ¹öjˆb” ²kˆàk Åkˆ) kˆwÇ  kˆ¥á ;"kˆ#ç ]$kˆëï 'kˆQó ++kˆù ñ0kˆ§Ù 5kˆË o:kˆ] o:kˆğ ëGkˆú ›Nkˆ/È ãQkˆ§ üVkˆxr makˆåÏ ¡akˆ ¡akˆƒÙ Äbkˆóã VfkˆÊu ÜykˆÉÃ ª€kˆ;û ª€kˆ	ï VkˆŠt kƒkˆKğ ‘kˆö '£kˆ›Î 5£kˆÛË »©kˆõ¸ Ê¯kˆ=ò Ê¯kˆÏÿ ¨´kˆo Ãkˆ Ékˆ’” Økˆ Ÿákˆ“ß {âkˆ;  ÆâkˆÍá [ãkˆÄ îkˆÿÇ îkˆ_ÿ îkˆö¡ •òkˆÊ ’÷kˆ ’÷kˆw÷ ·ûkˆÍ ükˆ” «lˆÆ¡ ÔlˆYá ¹lˆeï vlˆWÎ lˆ lˆµ× 5lˆƒ NlˆÆ¤ MZ       ÿÿ  ¸       @                                      º ´	Í!¸LÍ!This program cannot be run in DOS mode.
$       {˜_?ùï?ùï?ùï¬·w>ùï$dq>ùï$dE3ùï$ds;ùï$dD9ùï6|4ùï?ùî`ùï$d@<ùï$dt>ùï$dr>ùïRich?ùï                        PE  L ¥ X        à !
  D   .      ?C      `     a                   °     Z  @                   ğ|  Z   ¸s  Œ      ´           v  3      ô                                  f  @            `  ˆ                          .text   ÌC      D                    `.rdata  J   `      H              @  @.data   Ø   €      f              @  À.rsrc   ´         h              @  @.reloc  
          j              @  B                                                                                                                                                                                                                                                                                                                                j¸H aèr7  ‰MğÇTb aƒMüÿÿa aèù7  Ãj¸H aèM7  ‹ñ‰uğÇTb aƒMüÿÿa aöEtVÿ a aY‹ÆèÂ7  Â Ç`b aÃ…Ét‹jÿÃU‹ìöEV‹ñÇ`b atVÿ a aY‹Æ^]Â V‹0…öt'FƒÉÿğÁu‹‹ÎÿPFƒÉÿğÁu‹‹Î^ÿ`^ÃÃ3À@Â U‹ìƒäøjÿh™R ad¡    Pƒì SVW¡4€ a3ÄPD$0d£    ‹u3Û;ó„™  9^,„  9€   „„  9œ   „x  jPÿa aY‰D$‰\$8;Ãt
Pè’  ‹øë3ÿƒL$8ÿWL$,‰|$(èÑ
  ÇD$8   WD$(WPèWÿÿÿƒÄÇD$8   }èÖ  ‹L$$‰L$‹T$(‰T$ ;Ót
3ÛzCğÁÆD$8‹8‰‹H‰|$‰P‰L$ ÆD$8D$ èÑşÿÿ‹¾¨   2ÛéŒ   j†Œ   [9Xr‹ Np‰D$9Yr‹‰D$ë‰L$V89Zr‹‰D$ë‰T$F9Xr‹ ‰D$9^hr‹NTëNT9_r‹ë‹×9^r‹ë‹Æÿt$‹\$(ÿt$ÿt$ ÿt$(Pè…  ŠØƒÇ;¾¬   …hÿÿÿu|$èW  ‹D$;´„ atPD$ Pèé  ƒL$8ÿD$(èûıÿÿŠÃë2À‹L$0d‰    Y_^[‹å]Ãj ¸oK aèÃ4  ƒMüÿ‹EƒÀèÇıÿÿèN5  Â j¸†L aè 4  u}ğèß  ‹Eğ;´„ atW‹p‰uè‹@‰Eì…Àt
3ÉƒÀAğÁÇEü   ‹=da aÆFL‹F…ÀtPÿ×ƒf ‹F…ÀtPÿ×ƒf ƒMüÿEìèJıÿÿ°ë2ÀèË4  Ãj¸?R aè4  WEğèá  ‹uğ;5´„ at‹;Fsl3À‰Eè‰EìÇEü   ‹‰MÜMà‰Mğ‰Eà‰EäÆEü‹Mä‰Mì‰Eä‰EèÆEüMÜèó  PVEğPèF  ‹uğÆEüEà‰EğÆEüEäè·üÿÿƒMüÿEìè«üÿÿFè/4  Ãj¸ÂQ aèƒ3  ƒeü ¡´„ a‹‹ø‰Mğ;Éu-ÿp¹°„ aèl  ¡´„ a‰@¡´„ a‰ ¡´„ a‰@ƒ%¸„ a ë;Èt‹uğEğè»  VEìPè   9}ğuæƒMüÿÿ5´„ aÿ a aYè­3  Ãj¸ZQ aè3  ‹]€{ th b aÿœ` aEèm  ‹€z t‹{ë‹C€x t‹úë
‹E‹x;Ãux€ ‹su‰w¡´„ a9Xu‰xë9u‰>ë‰~‹´„ a9u€ t‹Îë‹‹Ïë‹È‹€x tö‰
‹´„ a9Zu{€ t‹Îë‹G‹Ïë‹È‹A€x tõ‰JëZ‰B‹‰;Cu‹ğë€ ‹pu‰w‰>‹S‰P‹K‰A‹´„ a9Yu‰Aë‹K9u‰ë‰A‹K‰HŠSŠHˆPˆK€{…ø   é®   €…å   ‹;ùug‹N€y uÆA‹ÎÆF è¶  ‹N€y ux‹€xu	‹A€xtc‹A€xu‹Æ@ÆA èÁ  ‹NŠFˆAÆF‹A‹ÎÆ@èi  ëx€y uÆA‹ÎÆF è  ‹€y u‹A€xu!‹€xuÆA ‹ş‹v¡´„ a;x…Dÿÿÿë1‹€xu‹AÆ@ÆA è  ‹ŠFˆAÆF‹‹ÎÆ@è,  ÆGC‰EğƒMüÿPè{   Sÿ a aƒ=¸„ a Yvÿ¸„ a‹M‹E‰èX1  Â U‹ìQQVEüès   ‹Mü¡´„ a;Èt‹;QrEüë‰EøEø‹ ‰‹ÇÉÃj ¸6Q aèv0  ƒMüÿÿuè   è1  Â j ¸QL aèV0  ƒMüÿ‹EƒÀ‰EƒMüÿƒÀèPùÿÿè×0  Â U‹ì‹´„ a‹J€y uV‹u‹69qs‹Ië‹Ñ‹	€y tì^‰]Â ‹A‹‰Q‹€z u‰J‹Q‰P‹´„ a;Ju‰Bë‹Q;
u‰ë‰B‰‰AÃ‹‹P‰‹P€z u‰J‹Q‰P‹´„ a;Ju‰Bë‹Q;Ju‰Bë‰‰H‰AÃÿ5´„ aÿ a aYÃ‹S2Û8Yu*‹Q8Zuë‹Ñ‹
8Yt÷‰[Ã‹;Qu
‰‹I8Ytï‰[Ãj¸ÙJ aè6/  jÿa aY…Àu-!EğEğPMäÿa aƒeü ÇEäTb aƒMüÿhxi aEäPè¾/  è–/  Ãj ¸6Q aèê.  ‹Ù‹}€ ‹÷u,ÿv‹Ëèİÿÿÿ‹6G‰EƒMüÿPè_şÿÿWÿ a a€~ Y‹ştÔèK/  Â j¸H aè.  ‹ñ‰uğÿuÿa aƒeü ÇTb aƒMüÿ‹Æè/  Â U‹ìƒì3ÀW‰Eü9¸„ auÿ5´„ a‹}jÿuèv  ‹Eé¹   ‹=´„ aSV‹u;7u‹}‹G;Fƒ‡   Vëu;÷u‹‹O‹U;JsrWP‹úë_‹E‹X9^v'Eü‰uüèa  ‹ 9Xs‹Eü‹H€y ‹}t¹Pë)9^s8Eü‰uüèXşÿÿ98‹Eüt;Xs!‹N€y ‹}tVj ëPjÿuèÎ   ‹Eëÿuuôè   ‹‹E‰^[_ÉÂ j¸¢Q aè~-  ¡´„ a‹}‹HƒÇ€y ‰EìÆEğu‹;Q‰Mì’Eğ€}ğ t‹	ë‹I€y tã€}ğ ‹]ì‰]èt(;uSj‹}EPèK   ‹ ‰ÆFë7Eèè{  ‹]è‹C;sÿuìÿuğëĞ‰}èƒMüÿWè’üÿÿÿuÿ a aY‰ÆF ‹Æè|-  Â j ¸~Q aèÎ,  ‹E=¸„ aTUUr$G‰EƒMüÿPèMüÿÿWÿ a aÇ$<b aÿ ` aÿ¸„ a‰G‹´„ a2Û;Áu‰y¡´„ a‰8¡´„ a‰xë&8]t‰8‹´„ a;u‰9ë‰x‹´„ a;Au‰y‹G‹÷éˆ   ‹F‹H;u3‹I8Yt2;pu	‹ğ‹Îè üÿÿ‹FÆ@‹F‹@ˆX‹F‹HèBüÿÿëH‹	8YuÆ@ÆA‹F‹@ˆX‹F‹pë(;0u	‹ğ‹Îèüÿÿ‹FÆ@‹F‹@ˆX‹F‹Hè»ûÿÿ‹F8X„oÿÿÿ¡´„ a‹@Æ@‹E‰8è:,  Â ‹S2Û8Yt‹Ië.‹8Zuë‹Ñ‹J8Ytö‰[Ã‹;u
‰‹I8Ytğ‹8Zu‰[Ãj¸µJ aè~+  ‹ñ3Û‰‰]üjÿa aY‰Eì3ÉAˆMü;Ãt!Ç `b a‰H‰HÆEüÇ tb a‹U‰PˆMüë3Àˆ]ü‰ƒMüÿ‹Æè˜+  Â 3Û9]tÿuè	  ÿuÿ a aYSSè˜+  Ìj¸Q aèü*  ‹ñè€ûÿÿ‰Eì‹´„ a‰‹´„ a‰H‹´„ a‰H3Ûf‰X‰]üH‰MèÆEü;Ët1‹‰ƒÁ‰Mä‹V‰‰YÆEü‹V‹y‰~‰Q‰^ÆEüÆEüÆEüˆ]üƒMüÿèğ*  Ãÿuìÿ a aY3ÛSSèÿ*  ÌV‹q…ötVèP  Vÿ a aY^Ã3ÀÂ j¸‡J aè*  ‹ñ‰uğƒMüÿöEÇ`b atVÿ a aY‹Æè*  Â V‹ñ‹FÇf a…ÀtPÿda aƒf ^ÃU‹ìV‹ñèØÿÿÿöEtVÿ a aY‹Æ^]Â j ¸dJ aè£)  ‹u3ÿWWWWhÔb aÿ`a a¹f a‰‰F‰}ü‰N‰~ÆEü‰N‰~ÆEüFPè2  ÆEüƒNÿF Pè!  ÆEüF$Pè  ÆEüF(Pè  ÆEüF,Pèú  ÆEüF4Pèí  ÆEüF<Pèà  ÆEü	F@PèÓ  ÆEü
FDPèÆ  ÆEüFHPè¹  ƒMüÿ‹Æè€)  Â j¸©I aèÒ(  ‹uÇEü   ‹FƒøÿtPÿ` aÆEüFH‰EğÆEü‹ j_+Çèa  ÆEü
FD‰EğÆEü
‹ +ÇèJ  ÆEü	F@‰EğÆEü	‹ +Çè3  ÆEüF<‰EğÆEü‹ +Çè  ÆEüF4‰EğÆEü‹ +Çè  ÆEüF,‰EğÆEü‹ +Çèî  ÆEüF(‰EğÆEü‹ +Çè×  ÆEüF$‰EğÆEü‹ +ÇèÀ  ÆEüF ‰EğÆEü‹ +Çè©  ÆEüF‰EğÆEü‹ +Çè’  ÆEüNèØıÿÿÆEü NèÌıÿÿƒMüÿ‹ÎèÁıÿÿèG(  Â h`  ¸ÄP aèÿ'  ‹E